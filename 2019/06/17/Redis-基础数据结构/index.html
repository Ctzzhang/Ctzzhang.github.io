<!-- build time:Tue Jul 16 2019 21:07:42 GMT+0800 (GMT+08:00) --><!DOCTYPE html><html lang="zh"><head><meta name="generator" content="Hexo 3.8.0"><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,minimum-scale=1,user-scalable=no,minimal-ui"><meta name="renderer" content="webkit"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black"><meta name="format-detection" content="telephone=no,email=no,adress=no"><meta name="theme-color" content="#000000"><meta http-equiv="window-target" content="_top"><title>Redis 基础数据结构 | ctzzhang</title><meta name="description" content="Redis 基础数据结构1.安装体验 Redis 需要使用 Linux 或者 Mac 环境，如果是 Windows 可以考虑使用虚拟机。主要方式有四种：使用 Docker 安装。通过 Github 源码编译。直接安装 apt-get install(Ubuntu)、yum install(RedHat) 或者 brew install(Mac)。如果读者懒于安装操作，也可以使用网页版的 Web R"><meta name="keywords" content="redis,缓存"><meta property="og:type" content="article"><meta property="og:title" content="Redis 基础数据结构"><meta property="og:url" content="http://localhost:4000/2019/06/17/Redis-基础数据结构/index.html"><meta property="og:site_name" content="ctzzhang"><meta property="og:description" content="Redis 基础数据结构1.安装体验 Redis 需要使用 Linux 或者 Mac 环境，如果是 Windows 可以考虑使用虚拟机。主要方式有四种：使用 Docker 安装。通过 Github 源码编译。直接安装 apt-get install(Ubuntu)、yum install(RedHat) 或者 brew install(Mac)。如果读者懒于安装操作，也可以使用网页版的 Web R"><meta property="og:locale" content="zh-CN"><meta property="og:image" content="http://localhost:4000/2019/06/17/Redis-基础数据结构/string.png"><meta property="og:image" content="http://localhost:4000/2019/06/17/Redis-基础数据结构/embstrandrawsum.png"><meta property="og:image" content="http://localhost:4000/2019/06/17/Redis-基础数据结构/hash%E7%BB%93%E6%9E%84%E5%9B%BE.png"><meta property="og:image" content="http://localhost:4000/2019/06/17/Redis-基础数据结构/rehash.png"><meta property="og:updated_time" content="2019-06-19T15:59:18.743Z"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="Redis 基础数据结构"><meta name="twitter:description" content="Redis 基础数据结构1.安装体验 Redis 需要使用 Linux 或者 Mac 环境，如果是 Windows 可以考虑使用虚拟机。主要方式有四种：使用 Docker 安装。通过 Github 源码编译。直接安装 apt-get install(Ubuntu)、yum install(RedHat) 或者 brew install(Mac)。如果读者懒于安装操作，也可以使用网页版的 Web R"><meta name="twitter:image" content="http://localhost:4000/2019/06/17/Redis-基础数据结构/string.png"><link rel="canonical" href="http://localhost:4000/2019/06/17/Redis-基础数据结构/index.html"><link rel="alternate" href="/atom.xml" title="ctzzhang" type="application/atom+xml"><link rel="icon" href="/favicon.png" type="image/x-icon"><link rel="stylesheet" href="/css/style.css"></head><body class="main-center theme-black" itemscope itemtype="http://schema.org/WebPage"><header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="slimContent"><div class="navbar-header"><div class="profile-block text-center"><a id="avatar" href="https://github.com/Ctzzhang" target="_blank"><img class="img-circle img-rotate" src="/images/avatar.jpg" width="200" height="200"></a><h2 id="name" class="hidden-xs hidden-sm">ctzzhang</h2><h3 id="title" class="hidden-xs hidden-sm hidden-md">Web Developer &amp; Designer</h3><small id="location" class="text-muted hidden-xs hidden-sm"><i class="icon icon-map-marker"></i> Shanghai, China</small></div><div class="search" id="search-form-wrap"><form class="search-form sidebar-form"><div class="input-group"><input type="text" class="search-form-input form-control" placeholder="搜索"> <span class="input-group-btn"><button type="submit" class="search-form-submit btn btn-flat" onclick="return!1"><i class="icon icon-search"></i></button></span></div></form><div class="ins-search"><div class="ins-search-mask"></div><div class="ins-search-container"><div class="ins-input-wrapper"><input type="text" class="ins-search-input" placeholder="想要查找什么..." x-webkit-speech> <button type="button" class="close ins-close ins-selectable" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">×</span></button></div><div class="ins-section-wrapper"><div class="ins-section-container"></div></div></div></div></div><button class="navbar-toggle collapsed" type="button" data-toggle="collapse" data-target="#main-navbar" aria-controls="main-navbar" aria-expanded="false"><span class="sr-only">Toggle navigation</span> <span class="icon-bar"></span> <span class="icon-bar"></span> <span class="icon-bar"></span></button></div><nav id="main-navbar" class="collapse navbar-collapse" itemscope itemtype="http://schema.org/SiteNavigationElement" role="navigation"><ul class="nav navbar-nav main-nav"><li class="menu-item menu-item-home"><a href="/."><i class="icon icon-home-fill"></i> <span class="menu-title">首页</span></a></li><li class="menu-item menu-item-archives"><a href="/archives"><i class="icon icon-archives-fill"></i> <span class="menu-title">归档</span></a></li><li class="menu-item menu-item-categories"><a href="/categories"><i class="icon icon-folder"></i> <span class="menu-title">分类</span></a></li><li class="menu-item menu-item-tags"><a href="/tags"><i class="icon icon-tags"></i> <span class="menu-title">标签</span></a></li><li class="menu-item menu-item-repository"><a href="/repository"><i class="icon icon-project"></i> <span class="menu-title">项目</span></a></li><li class="menu-item menu-item-books"><a href="/books"><i class="icon icon-book-fill"></i> <span class="menu-title">书单</span></a></li><li class="menu-item menu-item-links"><a href="/links"><i class="icon icon-friendship"></i> <span class="menu-title">友链</span></a></li><li class="menu-item menu-item-about"><a href="/about"><i class="icon icon-cup-fill"></i> <span class="menu-title">关于</span></a></li></ul><ul class="social-links"><li><a href="https://github.com/Ctzzhang" target="_blank" title="Github" data-toggle="tooltip" data-placement="top"><i class="icon icon-github"></i></a></li><li><a href="http://weibo.com/Ctzzhang" target="_blank" title="Weibo" data-toggle="tooltip" data-placement="top"><i class="icon icon-weibo"></i></a></li><li><a href="https://twitter.com/Ctzzhang" target="_blank" title="Twitter" data-toggle="tooltip" data-placement="top"><i class="icon icon-twitter"></i></a></li><li><a href="https://www.behance.net/Ctzzhang" target="_blank" title="Behance" data-toggle="tooltip" data-placement="top"><i class="icon icon-behance"></i></a></li><li><a href="/atom.xml" target="_blank" title="Rss" data-toggle="tooltip" data-placement="top"><i class="icon icon-rss"></i></a></li></ul></nav></div></header><aside class="sidebar" itemscope itemtype="http://schema.org/WPSideBar"><div class="slimContent"><div class="widget"><h3 class="widget-title">公告</h3><div class="widget-body"><div id="board"><div class="content"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span>您好，您是第<span id="busuanzi_value_site_pv"></span>位访客</span><p>欢迎交流与分享经验!</p></div></div></div></div><div class="widget"><h3 class="widget-title">分类</h3><div class="widget-body"><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Java基础/">Java基础</a><span class="category-list-count">1</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/Java基础/并发/">并发</a><span class="category-list-count">1</span></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/Redis/">Redis</a><span class="category-list-count">9</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/Redis/基本结构/">基本结构</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Redis/源码/">源码</a><span class="category-list-count">8</span></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/中间件/">中间件</a><span class="category-list-count">2</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/中间件/分布式/">分布式</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/中间件/限流组件/">限流组件</a><span class="category-list-count">1</span></li></ul></li></ul></div></div><div class="widget"><h3 class="widget-title">标签</h3><div class="widget-body"><ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Java基础/">Java基础</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/redis/">redis</a><span class="tag-list-count">5</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/中间件/">中间件</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/分布式/">分布式</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/字典/">字典</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/开发/">开发</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/数据结构/">数据结构</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/源码/">源码</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/线程池/">线程池</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/缓存/">缓存</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/锁/">锁</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/限流组件/">限流组件</a><span class="tag-list-count">1</span></li></ul></div></div><script type="text/javascript" charset="utf-8" src="/js/tagcloud.js"></script><script type="text/javascript" charset="utf-8" src="/js/tagcanvas.js"></script><div class="widget-wrap"><h3 class="widget-title">标签云</h3><div id="myCanvasContainer" class="widget tagcloud"><canvas width="250" height="250" id="resCanvas"><a href="/tags/Java基础/" style="font-size:10px">Java基础</a> <a href="/tags/redis/" style="font-size:20px">redis</a> <a href="/tags/中间件/" style="font-size:10px">中间件</a> <a href="/tags/分布式/" style="font-size:10px">分布式</a> <a href="/tags/字典/" style="font-size:10px">字典</a> <a href="/tags/开发/" style="font-size:10px">开发</a> <a href="/tags/数据结构/" style="font-size:16.67px">数据结构</a> <a href="/tags/源码/" style="font-size:10px">源码</a> <a href="/tags/线程池/" style="font-size:10px">线程池</a> <a href="/tags/缓存/" style="font-size:10px">缓存</a> <a href="/tags/锁/" style="font-size:13.33px">锁</a> <a href="/tags/限流组件/" style="font-size:10px">限流组件</a></canvas></div></div><div class="widget"><h3 class="widget-title">归档</h3><div class="widget-body"><ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/06/">六月 2019</a><span class="archive-list-count">13</span></li></ul></div></div><div class="widget"><h3 class="widget-title">最新文章</h3><div class="widget-body"><ul class="recent-post-list list-unstyled no-thumbnail"><li><div class="item-inner"><p class="item-category"><a class="category-link" href="/categories/Redis/">Redis</a><i class="icon icon-angle-right"></i><a class="category-link" href="/categories/Redis/源码/">源码</a></p><p class="item-title"><a href="/2019/06/19/Redis-基数树/" class="title">Redis 基数树</a></p><p class="item-date"><time datetime="2019-06-19T14:41:33.000Z" itemprop="datePublished">2019-06-19</time></p></div></li><li><div class="item-inner"><p class="item-category"><a class="category-link" href="/categories/Redis/">Redis</a><i class="icon icon-angle-right"></i><a class="category-link" href="/categories/Redis/源码/">源码</a></p><p class="item-title"><a href="/2019/06/19/Redis-紧凑列表结构/" class="title">Redis 紧凑列表结构</a></p><p class="item-date"><time datetime="2019-06-19T14:37:42.000Z" itemprop="datePublished">2019-06-19</time></p></div></li><li><div class="item-inner"><p class="item-category"><a class="category-link" href="/categories/Redis/">Redis</a><i class="icon icon-angle-right"></i><a class="category-link" href="/categories/Redis/源码/">源码</a></p><p class="item-title"><a href="/2019/06/19/Redis-跳跃列表结构/" class="title">Redis 跳跃列表结构</a></p><p class="item-date"><time datetime="2019-06-19T14:29:39.000Z" itemprop="datePublished">2019-06-19</time></p></div></li><li><div class="item-inner"><p class="item-category"><a class="category-link" href="/categories/Redis/">Redis</a><i class="icon icon-angle-right"></i><a class="category-link" href="/categories/Redis/源码/">源码</a></p><p class="item-title"><a href="/2019/06/19/Redis-快速列表结构/" class="title">Redis 快速列表结构</a></p><p class="item-date"><time datetime="2019-06-19T14:24:06.000Z" itemprop="datePublished">2019-06-19</time></p></div></li><li><div class="item-inner"><p class="item-category"><a class="category-link" href="/categories/Redis/">Redis</a><i class="icon icon-angle-right"></i><a class="category-link" href="/categories/Redis/源码/">源码</a></p><p class="item-title"><a href="/2019/06/19/Redis-压缩列表结构/" class="title">Redis 压缩列表结构</a></p><p class="item-date"><time datetime="2019-06-19T13:24:54.000Z" itemprop="datePublished">2019-06-19</time></p></div></li></ul></div></div></div></aside><main class="main" role="main"><div class="content"><article id="post-Redis-基础数据结构" class="article article-type-post" itemscope itemtype="http://schema.org/BlogPosting"><div class="article-header"><h1 class="article-title" itemprop="name">Redis 基础数据结构</h1><div class="article-meta"><span class="article-date"><i class="icon icon-calendar-check"></i> <a href="/2019/06/17/Redis-基础数据结构/" class="article-date"><time datetime="2019-06-17T14:58:23.000Z" itemprop="datePublished">2019-06-17</time></a></span> <span class="article-category"><i class="icon icon-folder"></i> <a class="article-category-link" href="/categories/Redis/">Redis</a>►<a class="article-category-link" href="/categories/Redis/基本结构/">基本结构</a></span> <span class="article-tag"><i class="icon icon-tags"></i> <a class="article-tag-link" href="/tags/redis/">redis</a>, <a class="article-tag-link" href="/tags/缓存/">缓存</a></span> <span class="article-read hidden-xs"><i class="icon icon-eye-fill" aria-hidden="true"></i> <span id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv">0</span></span></span> <span class="post-comment"><i class="icon icon-comment"></i> <a href="/2019/06/17/Redis-基础数据结构/#comments" class="article-comment-link">评论</a></span> <span class="post-wordcount hidden-xs" itemprop="wordCount">字数统计: 4.2k(字)</span> <span class="post-readcount hidden-xs" itemprop="timeRequired">阅读时长: 17(分)</span></div></div><div class="article-entry marked-body" itemprop="articleBody"><h1 id="Redis-基础数据结构"><a href="#Redis-基础数据结构" class="headerlink" title="Redis 基础数据结构"></a>Redis 基础数据结构</h1><h2 id="1-安装"><a href="#1-安装" class="headerlink" title="1.安装"></a>1.安装</h2><p>体验 Redis 需要使用 Linux 或者 Mac 环境，如果是 Windows 可以考虑使用虚拟机。主要方式有四种：</p><ol><li>使用 Docker 安装。</li><li>通过 Github 源码编译。</li><li>直接安装 apt-get install(Ubuntu)、yum install(RedHat) 或者 brew install(Mac)。</li><li>如果读者懒于安装操作，也可以使用网页版的 <a href="https://link.juejin.im/?target=https%3A%2F%2Ftry.redis.io%2F" target="_blank" rel="noopener">Web Redis</a> 直接体验。</li></ol><h2 id="2-基础数据结构"><a href="#2-基础数据结构" class="headerlink" title="2.基础数据结构"></a>2.基础数据结构</h2><p>Redis 有五种常用的数据类型，分别是string (字符串)、list (列表)、set (集合)、hash (哈希) 和 zset (有序集合)。一般我们也是经常使用这五种类型的数据，下面分别简述一下其中的内部结构是怎么样的。</p><h4 id="2-1-string-字符串"><a href="#2-1-string-字符串" class="headerlink" title="2.1 string (字符串)"></a>2.1 string (字符串)</h4><p>string是Redis中最为简单的数据结构，通过用Key-value的方式去存储、查找和更新。对于不同的数据，value的数据结构不同。</p><p>字符串结构使用非常广泛，一个常见的用途就是缓存用户信息。我们将用户信息结构体使用 JSON 序列化成字符串，然后将序列化后的字符串塞进 Redis 来缓存。同样，取用户信息会经过一次反序列化的过程。</p><p><img src="//localhost:4000/2019/06/17/Redis-基础数据结构/string.png" alt="scheduledthreadpoolexecutor"></p><p>Redis 的字符串是动态字符串，是可以修改的字符串，内部结构实现上类似于 Java 的 ArrayList，采用预分配冗余空间的方式来减少内存的频繁分配，如图中所示，内部为当前字符串实际分配的空间 capacity 一般要高于实际字符串长度 len。当字符串长度小于 1M 时，扩容都是加倍现有的空间，如果超过 1M，扩容时一次只会多扩 1M 的空间。需要注意的是字符串最大长度为 512M。</p><p>在内存中是以字节数组的存储的。Redis 的字符串叫着「SDS」，也就是Simple Dynamic String。它的结构是一个带长度信息的字节数组。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SDS</span>&lt;T&gt; &#123;</span></span><br><span class="line">T capacity; <span class="comment">// 数组容量</span></span><br><span class="line">T len; <span class="comment">// 数组长度</span></span><br><span class="line">byte flags; <span class="comment">// 特殊标识位，不理睬它</span></span><br><span class="line">byte[] content; <span class="comment">// 数组内容</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>参数分析：</p><ul><li><p>capacity是指数组的长度，一般会比实际的内容多分配一些空间</p></li><li><p>len是实际的字符串的真是长度</p></li><li><p>content是存储了真正的字符串的内容</p></li></ul><p>字符串是可以修改的字符串，它要支持 append 操作。如果数组没有冗余空间，那么追加操作必然涉及到分配新数组，然后将旧内容复制过来，再 append 新内容。如果字符串的长度非常长，这样的内存分配和复制开销就会非常大。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Append the specified binary-safe string pointed by 't' of 'len' bytes to the</span></span><br><span class="line"><span class="comment">* end of the specified sds string 's'.</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* After the call, the passed sds string is no longer valid and all the</span></span><br><span class="line"><span class="comment">* references must be substituted with the new pointer returned by the call. */</span></span><br><span class="line"><span class="function">sds <span class="title">sdscatlen</span><span class="params">(sds s, <span class="keyword">const</span> <span class="keyword">void</span> *t, <span class="keyword">size_t</span> len)</span> </span>&#123;</span><br><span class="line"><span class="keyword">size_t</span> curlen = sdslen(s); <span class="comment">// 原字符串长度</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 按需调整空间，如果 capacity 不够容纳追加的内容，就会重新分配字节数组并复制原字符串的内容到新数组中</span></span><br><span class="line">s = sdsMakeRoomFor(s,len);</span><br><span class="line"><span class="keyword">if</span> (s == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>; <span class="comment">// 内存不足</span></span><br><span class="line"><span class="built_in">memcpy</span>(s+curlen, t, len); <span class="comment">// 追加目标字符串的内容到字节数组中</span></span><br><span class="line">sdssetlen(s, curlen+len); <span class="comment">// 设置追加后的长度值</span></span><br><span class="line">s[curlen+len] = <span class="string">'\0'</span>; <span class="comment">// 让字符串以\0 结尾，便于调试打印，还可以直接使用 glibc 的字符串函数进行操作</span></span><br><span class="line"><span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的 SDS 结构使用了范型 T，为什么不直接用 int 呢，这是因为当字符串比较短时，len 和 capacity 可以使用 byte 和 short 来表示，Redis 为了对内存做极致的优化，不同长度的字符串使用不同的结构体来表示。<br>Redis 规定字符串的长度不得超过 512M 字节。创建字符串时 len 和 capacity 一样长，不会多分配冗余空间，这是因为绝大多数场景下我们不会使用 append 操作来修改字符串。</p><h5 id="embstr-vs-raw"><a href="#embstr-vs-raw" class="headerlink" title="embstr vs raw"></a>embstr vs raw</h5><p>Redis的两种存储字符串的方式。在长度特别短时，使用 emb 形式存储 (embeded)，当长度超过 44 时，使用 raw 形式存储。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; set codehole abcdefghijklmnopqrstuvwxyz0123456789123456789</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; debug object codehole</span><br><span class="line">Value at:00007FD73D46E2D0 refcount:1 encoding:raw serializedlength:46 lru:505657 lru_seconds_idle:2</span><br><span class="line">127.0.0.1:6379&gt; set codehole abcdefghij</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; debug object codehole</span><br><span class="line">Value at:00007FD73D40A6A0 refcount:1 encoding:embstr serializedlength:11 lru:505690 lru_seconds_idle:2</span><br></pre></td></tr></table></figure><p>注意上面 debug object 输出中有个 encoding 字段，一个字符的差别，存储形式就发生了变化。这是为什么呢？</p><p>我们首先来了解一下 Redis 对象头结构体，所有的 Redis 对象都有下面的这个结构头:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">RedisObject</span> &#123;</span></span><br><span class="line">int4 type; <span class="comment">// 4bits</span></span><br><span class="line">int4 encoding; <span class="comment">// 4bits</span></span><br><span class="line">int24 lru; <span class="comment">// 24bits</span></span><br><span class="line">int32 refcount; <span class="comment">// 4bytes</span></span><br><span class="line"><span class="keyword">void</span> *ptr; <span class="comment">// 8bytes，64-bit system</span></span><br><span class="line">&#125; robj;</span><br></pre></td></tr></table></figure><p>不同的对象具有不同的类型 type(4bit)，同一个类型的 type 会有不同的存储形式 encoding(4bit)，为了记录对象的 LRU 信息，使用了 24 个 bit 来记录 LRU 信息。每个对象都有个引用计数，当引用计数为零时，对象就会被销毁，内存被回收。ptr指针将指向对象内容 (body) 的具体存储位置。这样一个 RedisObject 对象头需要占据 16 字节的存储空间。</p><p>接着我们再看 SDS 结构体的大小，在字符串比较小时，SDS 对象头的大小是capacity+3，至少是 3。意味着分配一个字符串的最小空间占用为 19 字节 (16+3)。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SDS</span> &#123;</span></span><br><span class="line">int8 capacity; <span class="comment">// 1byte</span></span><br><span class="line">int8 len; <span class="comment">// 1byte</span></span><br><span class="line">int8 flags; <span class="comment">// 1byte</span></span><br><span class="line">byte[] content; <span class="comment">// 内联数组，长度为 capacity</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="//localhost:4000/2019/06/17/Redis-基础数据结构/embstrandrawsum.png" alt="scheduledthreadpoolexecutor"></p><p>如图所示，embstr 存储形式是这样一种存储形式，它将 RedisObject 对象头和 SDS 对象连续存在一起，使用 malloc 方法一次分配。而 raw 存储形式不一样，它需要两次 malloc，两个对象头在内存地址上一般是不连续的。</p><p>而内存分配器 jemalloc/tcmalloc 等分配内存大小的单位都是 2、4、8、16、32、64 等等，为了能容纳一个完整的 embstr 对象，jemalloc 最少会分配 32 字节的空间，如果字符串再稍微长一点，那就是 64 字节的空间。如果总体超出了 64 字节，Redis 认为它是一个大字符串，不再使用 emdstr 形式存储，而该用 raw 形式。</p><p>当内存分配器分配了 64 空间时，那这个字符串的长度最大可以是多少呢？这个长度就是 44。那为什么是 44 呢？</p><p>前面我们提到 SDS 结构体中的 content 中的字符串是以字节\0结尾的字符串，之所以多出这样一个字节，是为了便于直接使用 glibc 的字符串处理函数，以及为了便于字符串的调试打印输出。</p><p>看上面这张图可以算出，留给 content 的长度最多只有 45(64-19) 字节了。字符串又是以\0结尾，所以 embstr 最大能容纳的字符串长度就是 44。</p><h5 id="扩容策略"><a href="#扩容策略" class="headerlink" title="扩容策略"></a>扩容策略</h5><p>字符串在长度小于 1M 之前，扩容空间采用加倍策略，也就是保留 100% 的冗余空间。当长度超过 1M 之后，为了避免加倍后的冗余空间过大而导致浪费，每次扩容只会多分配 1M 大小的冗余空间。</p><h5 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h5><h6 id="键值对"><a href="#键值对" class="headerlink" title="键值对"></a>键值对</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt; set name codehole</span><br><span class="line">OK</span><br><span class="line">&gt; get name</span><br><span class="line">&quot;codehole&quot;</span><br><span class="line">&gt; exists name</span><br><span class="line">(integer) 1</span><br><span class="line">&gt; del name</span><br><span class="line">(integer) 1</span><br><span class="line">&gt; get name</span><br><span class="line">(nil)</span><br></pre></td></tr></table></figure><h6 id="批量键值对"><a href="#批量键值对" class="headerlink" title="批量键值对"></a>批量键值对</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&gt; set name1 codehole</span><br><span class="line">OK</span><br><span class="line">&gt; set name2 holycoder</span><br><span class="line">OK</span><br><span class="line">&gt; mget name1 name2 name3 # 返回一个列表</span><br><span class="line">1) &quot;codehole&quot;</span><br><span class="line">2) &quot;holycoder&quot;</span><br><span class="line">3) (nil)</span><br><span class="line">&gt; mset name1 boy name2 girl name3 unknown</span><br><span class="line">&gt; mget name1 name2 name3</span><br><span class="line">1) &quot;boy&quot;</span><br><span class="line">2) &quot;girl&quot;</span><br><span class="line">3) &quot;unknown&quot;</span><br></pre></td></tr></table></figure><h6 id="过期和-set-命令扩展"><a href="#过期和-set-命令扩展" class="headerlink" title="过期和 set 命令扩展"></a>过期和 set 命令扩展</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&gt; set name codehole</span><br><span class="line">&gt; get name</span><br><span class="line">&quot;codehole&quot;</span><br><span class="line">&gt; expire name 5 # 5s 后过期</span><br><span class="line">... # wait for 5s</span><br><span class="line">&gt; get name</span><br><span class="line">(nil)</span><br><span class="line"></span><br><span class="line">&gt; setex name 5 codehole # 5s 后过期，等价于 set+expire</span><br><span class="line">&gt; get name</span><br><span class="line">&quot;codehole&quot;</span><br><span class="line">... # wait for 5s</span><br><span class="line">&gt; get name</span><br><span class="line">(nil)</span><br><span class="line"></span><br><span class="line">&gt; setnx name codehole # 如果 name 不存在就执行 set 创建</span><br><span class="line">(integer) 1</span><br><span class="line">&gt; get name</span><br><span class="line">&quot;codehole&quot;</span><br><span class="line">&gt; setnx name holycoder</span><br><span class="line">(integer) 0 # 因为 name 已经存在，所以 set 创建不成功</span><br><span class="line">&gt; get name</span><br><span class="line">&quot;codehole&quot; # 没有改变</span><br></pre></td></tr></table></figure><h6 id="计数"><a href="#计数" class="headerlink" title="计数"></a>计数</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&gt; set age 30</span><br><span class="line">OK</span><br><span class="line">&gt; incr age</span><br><span class="line">(integer) 31</span><br><span class="line">&gt; incrby age 5</span><br><span class="line">(integer) 36</span><br><span class="line">&gt; incrby age -5</span><br><span class="line">(integer) 31</span><br><span class="line">&gt; set codehole 9223372036854775807 # Long.Max</span><br><span class="line">OK</span><br><span class="line">&gt; incr codehole</span><br><span class="line">(error) ERR increment or decrement would overflow</span><br></pre></td></tr></table></figure><h3 id="2-2-list-列表"><a href="#2-2-list-列表" class="headerlink" title="2.2 list (列表)"></a>2.2 list (列表)</h3><p>Redis的列表相当于Java的ArrayList，是由链表组成的，所以插入和删除较快，但是查询比较慢。list中的最后一个元素弹出后，该数据结构就被删除，内存也被回收了。</p><h4 id="右边进左边出：队列"><a href="#右边进左边出：队列" class="headerlink" title="右边进左边出：队列"></a>右边进左边出：队列</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&gt; rpush books python java golang</span><br><span class="line">(integer) 3</span><br><span class="line">&gt; llen books</span><br><span class="line">(integer) 3</span><br><span class="line">&gt; lpop books</span><br><span class="line">&quot;python&quot;</span><br><span class="line">&gt; lpop books</span><br><span class="line">&quot;java&quot;</span><br><span class="line">&gt; lpop books</span><br><span class="line">&quot;golang&quot;</span><br><span class="line">&gt; lpop books</span><br><span class="line">(nil)</span><br></pre></td></tr></table></figure><h4 id="右边进右边出：栈"><a href="#右边进右边出：栈" class="headerlink" title="右边进右边出：栈"></a>右边进右边出：栈</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt; rpush books python java golang</span><br><span class="line">(integer) 3</span><br><span class="line">&gt; rpop books</span><br><span class="line">&quot;golang&quot;</span><br><span class="line">&gt; rpop books</span><br><span class="line">&quot;java&quot;</span><br><span class="line">&gt; rpop books</span><br><span class="line">&quot;python&quot;</span><br><span class="line">&gt; rpop books</span><br><span class="line">(nil)</span><br></pre></td></tr></table></figure><h4 id="慢操作"><a href="#慢操作" class="headerlink" title="慢操作"></a>慢操作</h4><p>lindex 相当于 Java 链表的get(int index)方法，它需要对链表进行遍历，性能随着参数index增大而变差。</p><p>ltrim 和字面上的含义不太一样，个人觉得它叫 lretain(保留) 更合适一些，因为 ltrim 跟的两个参数start_index和end_index定义了一个区间，在这个区间内的值，ltrim 要保留，区间之外统统砍掉。我们可以通过ltrim来实现一个定长的链表，这一点非常有用。</p><p>index 可以为负数，index=-1表示倒数第一个元素，同样index=-2表示倒数第二个元素。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&gt; rpush books python java golang</span><br><span class="line">(integer) 3</span><br><span class="line">&gt; lindex books 1 # O(n) 慎用</span><br><span class="line">&quot;java&quot;</span><br><span class="line">&gt; lrange books 0 -1 # 获取所有元素，O(n) 慎用</span><br><span class="line">1) &quot;python&quot;</span><br><span class="line">2) &quot;java&quot;</span><br><span class="line">3) &quot;golang&quot;</span><br><span class="line">&gt; ltrim books 1 -1 # O(n) 慎用</span><br><span class="line">OK</span><br><span class="line">&gt; lrange books 0 -1</span><br><span class="line">1) &quot;java&quot;</span><br><span class="line">2) &quot;golang&quot;</span><br><span class="line">&gt; ltrim books 1 0 # 这其实是清空了整个列表，因为区间范围长度为负</span><br><span class="line">OK</span><br><span class="line">&gt; llen books</span><br><span class="line">(integer) 0</span><br></pre></td></tr></table></figure><h4 id="底层数据结构"><a href="#底层数据结构" class="headerlink" title="底层数据结构"></a>底层数据结构</h4><p>Redis 底层存储的还不是一个简单的 linkedlist，而是称之为快速链表 quicklist 的一个结构。</p><p>首先在列表元素较少的情况下会使用一块连续的内存存储，这个结构是 ziplist，也即是压缩列表。它将所有的元素紧挨着一起存储，分配的是一块连续的内存。当数据量比较多的时候才会改成 quicklist。因为普通的链表需要的附加指针空间太大，会比较浪费空间，而且会加重内存的碎片化。比如这个列表里存的只是 int 类型的数据，结构上还需要两个额外的指针 prev 和 next 。所以 Redis 将链表和 ziplist 结合起来组成了 quicklist。也就是将多个 ziplist 使用双向指针串起来使用。这样既满足了快速的插入删除性能，又不会出现太大的空间冗余。</p><p>可以查看列表中的压缩列表和快速列表。</p><h3 id="2-3-hash-哈希"><a href="#2-3-hash-哈希" class="headerlink" title="2.3 hash (哈希)"></a>2.3 hash (哈希)</h3><p>hash类比于Java中的HashMap，它是无序字典。内部实现结构上同 Java 的 HashMap 也是一致的，同样的数组 + 链表二维结构。第一维 hash 的数组位置碰撞时，就会将碰撞的元素使用链表串接起来。</p><p><img src="//localhost:4000/2019/06/17/Redis-基础数据结构/hash%E7%BB%93%E6%9E%84%E5%9B%BE.png" alt="scheduledthreadpoolexecutor"></p><p>不同的是，Redis 的字典的值只能是字符串，另外它们 rehash 的方式不一样，因为 Java 的 HashMap 在字典很大时，rehash 是个耗时的操作，需要一次性全部 rehash。Redis 为了高性能，不能堵塞服务，所以采用了渐进式 rehash 策略。</p><p><img src="//localhost:4000/2019/06/17/Redis-基础数据结构/rehash.png" alt="scheduledthreadpoolexecutor"></p><p>hash 结构也可以用来存储用户信息，不同于字符串一次性需要全部序列化整个对象，hash 可以对用户结构中的每个字段单独存储。这样当我们需要获取用户信息时可以进行部分获取。而以整个字符串的形式去保存用户信息的话就只能一次性全部读取，这样就会比较浪费网络流量。</p><p>hash 也有缺点，hash 结构的存储消耗要高于单个字符串，到底该使用 hash 还是字符串，需要根据实际情况再三权衡。</p><h4 id="指令-1"><a href="#指令-1" class="headerlink" title="指令"></a>指令</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&gt; hset books java &quot;think in java&quot; # 命令行的字符串如果包含空格，要用引号括起来</span><br><span class="line">(integer) 1</span><br><span class="line">&gt; hset books golang &quot;concurrency in go&quot;</span><br><span class="line">(integer) 1</span><br><span class="line">&gt; hset books python &quot;python cookbook&quot;</span><br><span class="line">(integer) 1</span><br><span class="line">&gt; hgetall books # entries()，key 和 value 间隔出现</span><br><span class="line">1) &quot;java&quot;</span><br><span class="line">2) &quot;think in java&quot;</span><br><span class="line">3) &quot;golang&quot;</span><br><span class="line">4) &quot;concurrency in go&quot;</span><br><span class="line">5) &quot;python&quot;</span><br><span class="line">6) &quot;python cookbook&quot;</span><br><span class="line">&gt; hlen books</span><br><span class="line">(integer) 3</span><br><span class="line">&gt; hget books java</span><br><span class="line">&quot;think in java&quot;</span><br><span class="line">&gt; hset books golang &quot;learning go programming&quot; # 因为是更新操作，所以返回 0</span><br><span class="line">(integer) 0</span><br><span class="line">&gt; hget books golang</span><br><span class="line">&quot;learning go programming&quot;</span><br><span class="line">&gt; hmset books java &quot;effective java&quot; python &quot;learning python&quot; golang &quot;modern golang programming&quot; # 批量 set</span><br><span class="line">OK</span><br></pre></td></tr></table></figure><p>同字符串一样，hash 结构中的单个子 key 也可以进行计数，它对应的指令是 hincrby，和 incr 使用基本一样。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 老钱又老了一岁</span><br><span class="line">&gt; hincrby user-laoqian age 1</span><br><span class="line">(integer) 30</span><br></pre></td></tr></table></figure><p>关于字典的内部结构实现，可以查看「字典」内部。</p><h3 id="2-4-set-集合"><a href="#2-4-set-集合" class="headerlink" title="2.4 set((集合)"></a>2.4 set((集合)</h3><p>set对比Java中的HashSet相似，内部value也唯一无序的。它的内部实现相当于一个特殊的字典，字典中所有的 value 都是一个值NULL。和list相同，当集合中最后一个元素移除之后，数据结构自动删除，内存被回收。</p><p>可以在去重应用环境中。</p><h4 id="指令-2"><a href="#指令-2" class="headerlink" title="指令"></a>指令</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&gt; sadd books python</span><br><span class="line">(integer) 1</span><br><span class="line">&gt; sadd books python # 重复</span><br><span class="line">(integer) 0</span><br><span class="line">&gt; sadd books java golang</span><br><span class="line">(integer) 2</span><br><span class="line">&gt; smembers books # 注意顺序，和插入的并不一致，因为 set 是无序的</span><br><span class="line">1) &quot;java&quot;</span><br><span class="line">2) &quot;python&quot;</span><br><span class="line">3) &quot;golang&quot;</span><br><span class="line">&gt; sismember books java # 查询某个 value 是否存在，相当于 contains(o)</span><br><span class="line">(integer) 1</span><br><span class="line">&gt; sismember books rust</span><br><span class="line">(integer) 0</span><br><span class="line">&gt; scard books # 获取长度相当于 count()</span><br><span class="line">(integer) 3</span><br><span class="line">&gt; spop books # 弹出一个</span><br><span class="line">&quot;java&quot;</span><br></pre></td></tr></table></figure><h3 id="2-5-zset-有序集合"><a href="#2-5-zset-有序集合" class="headerlink" title="2.5 zset (有序集合)"></a>2.5 zset (有序集合)</h3><p>zset 可能是 Redis 提供的最为特色的数据结构，它也是在面试中面试官最爱问的数据结构。它类似于 Java 的 SortedSet 和 HashMap 的结合体，一方面它是一个 set，保证了内部 value 的唯一性，另一方面它可以给每个 value 赋予一个 score，代表这个 value 的排序权重。它的内部实现用的是一种叫做「跳跃列表」的数据结构。</p><p>zset 中最后一个 value 被移除后，数据结构自动删除，内存被回收。</p><h4 id="指令-3"><a href="#指令-3" class="headerlink" title="指令"></a>指令</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">&gt; zadd books 9.0 &quot;think in java&quot;</span><br><span class="line">(integer) 1</span><br><span class="line">&gt; zadd books 8.9 &quot;java concurrency&quot;</span><br><span class="line">(integer) 1</span><br><span class="line">&gt; zadd books 8.6 &quot;java cookbook&quot;</span><br><span class="line">(integer) 1</span><br><span class="line">&gt; zrange books 0 -1 # 按 score 排序列出，参数区间为排名范围</span><br><span class="line">1) &quot;java cookbook&quot;</span><br><span class="line">2) &quot;java concurrency&quot;</span><br><span class="line">3) &quot;think in java&quot;</span><br><span class="line">&gt; zrevrange books 0 -1 # 按 score 逆序列出，参数区间为排名范围</span><br><span class="line">1) &quot;think in java&quot;</span><br><span class="line">2) &quot;java concurrency&quot;</span><br><span class="line">3) &quot;java cookbook&quot;</span><br><span class="line">&gt; zcard books # 相当于 count()</span><br><span class="line">(integer) 3</span><br><span class="line">&gt; zscore books &quot;java concurrency&quot; # 获取指定 value 的 score</span><br><span class="line">&quot;8.9000000000000004&quot; # 内部 score 使用 double 类型进行存储，所以存在小数点精度问题</span><br><span class="line">&gt; zrank books &quot;java concurrency&quot; # 排名</span><br><span class="line">(integer) 1</span><br><span class="line">&gt; zrangebyscore books 0 8.91 # 根据分值区间遍历 zset</span><br><span class="line">1) &quot;java cookbook&quot;</span><br><span class="line">2) &quot;java concurrency&quot;</span><br><span class="line">&gt; zrangebyscore books -inf 8.91 withscores # 根据分值区间 (-∞, 8.91] 遍历 zset，同时返回分值。inf 代表 infinite，无穷大的意思。</span><br><span class="line">1) &quot;java cookbook&quot;</span><br><span class="line">2) &quot;8.5999999999999996&quot;</span><br><span class="line">3) &quot;java concurrency&quot;</span><br><span class="line">4) &quot;8.9000000000000004&quot;</span><br><span class="line">&gt; zrem books &quot;java concurrency&quot; # 删除 value</span><br><span class="line">(integer) 1</span><br><span class="line">&gt; zrange books 0 -1</span><br><span class="line">1) &quot;java cookbook&quot;</span><br><span class="line">2) &quot;think in java&quot;</span><br></pre></td></tr></table></figure><h2 id="3-其他通用规则"><a href="#3-其他通用规则" class="headerlink" title="3.其他通用规则"></a>3.其他通用规则</h2><p>list/set/hash/zset 这四种数据结构是容器型数据结构，它们共享下面两条通用规则：</p><ol><li><p>create if not exists</p><p>如果容器不存在，那就创建一个，再进行操作。比如 rpush 操作刚开始是没有列表的，Redis 就会自动创建一个，然后再 rpush 进去新元素。</p></li><li><p>drop if no elements</p><p>如果容器里元素没有了，那么立即删除元素，释放内存。这意味着 lpop 操作到最后一个元素，列表就消失了。</p></li></ol><ol start="3"><li><p>过期时间</p><p>Redis 所有的数据结构都可以设置过期时间，时间到了，Redis 会自动删除相应的对象。需要注意的是过期是以对象为单位，比如一个 hash 结构的过期是整个 hash 对象的过期，而不是其中的某个子 key。</p><p>还有一个需要特别注意的地方是如果一个字符串已经设置了过期时间，然后你调用了 set 方法修改了它，它的过期时间会消失。</p></li></ol></div><div class="article-footer"><blockquote class="mt-2x"><ul class="post-copyright list-unstyled"><li class="post-copyright-link hidden-xs"><strong>本文链接：</strong> <a href="http://localhost:4000/2019/06/17/Redis-基础数据结构/" title="Redis 基础数据结构" target="_blank" rel="external">http://localhost:4000/2019/06/17/Redis-基础数据结构/</a></li><li class="post-copyright-license"><strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="http://creativecommons.org/licenses/by/4.0/deed.zh" target="_blank" rel="external">CC BY 4.0 CN协议</a> 许可协议。转载请注明出处！</li></ul></blockquote><div class="panel panel-default panel-badger"><div class="panel-body"><figure class="media"><div class="media-left"><a href="https://github.com/Ctzzhang" target="_blank" class="img-burn thumb-sm visible-lg"><img src="/images/avatar.jpg" class="img-rounded w-full" alt></a></div><div class="media-body"><h3 class="media-heading"><a href="https://github.com/Ctzzhang" target="_blank"><span class="text-dark">ctzzhang</span><small class="ml-1x">Web Developer &amp; Designer</small></a></h3><div>个人博客</div></div></figure></div></div></div></article><section id="comments"><div id="vcomments"></div></section></div><nav class="bar bar-footer clearfix" data-stick-bottom><div class="bar-inner"><ul class="pager pull-left"><li class="prev"><a href="/2019/06/18/Redis-源码内部结构综述/" title="Redis 源码内部结构综述"><i class="icon icon-angle-left" aria-hidden="true"></i><span>&nbsp;&nbsp;上一篇</span></a></li><li class="next"><a href="/2019/06/16/Java线程池/" title="Java线程池的原理分析"><span>下一篇&nbsp;&nbsp;</span><i class="icon icon-angle-right" aria-hidden="true"></i></a></li></ul><button type="button" class="btn btn-fancy btn-donate pop-onhover bg-gradient-warning" data-toggle="modal" data-target="#donateModal"><span>赏</span></button><div class="bar-right"><div class="share-component" data-sites="weibo,qq,wechat,facebook,twitter" data-mobile-sites="weibo,qq,qzone"></div></div></div></nav><div class="modal modal-center modal-small modal-xs-full fade" id="donateModal" tabindex="-1" role="dialog"><div class="modal-dialog" role="document"><div class="modal-content donate"><button type="button" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">&times;</span></button><div class="modal-body"><div class="donate-box"><div class="donate-head"><p>感谢您的支持，我会继续努力的!</p></div><div class="tab-content"><div role="tabpanel" class="tab-pane fade active in" id="alipay"><div class="donate-payimg"><img src="/images/donate/alipayimg.png" alt="扫码支持" title="扫一扫"></div><p class="text-muted mv">扫码打赏，你说多少就多少</p><p class="text-grey">打开支付宝扫一扫，即可进行扫码打赏哦</p></div><div role="tabpanel" class="tab-pane fade" id="wechatpay"><div class="donate-payimg"><img src="/images/donate/wechatpayimg.png" alt="扫码支持" title="扫一扫"></div><p class="text-muted mv">扫码打赏，你说多少就多少</p><p class="text-grey">打开微信扫一扫，即可进行扫码打赏哦</p></div></div><div class="donate-footer"><ul class="nav nav-tabs nav-justified" role="tablist"><li role="presentation" class="active"><a href="#alipay" id="alipay-tab" role="tab" data-toggle="tab" aria-controls="alipay" aria-expanded="true"><i class="icon icon-alipay"></i> 支付宝</a></li><li role="presentation"><a href="#wechatpay" role="tab" id="wechatpay-tab" data-toggle="tab" aria-controls="wechatpay" aria-expanded="false"><i class="icon icon-wepay"></i> 微信支付</a></li></ul></div></div></div></div></div></div></main><footer class="footer" itemscope itemtype="http://schema.org/WPFooter"><ul class="social-links"><li><a href="https://github.com/Ctzzhang" target="_blank" title="Github" data-toggle="tooltip" data-placement="top"><i class="icon icon-github"></i></a></li><li><a href="http://weibo.com/Ctzzhang" target="_blank" title="Weibo" data-toggle="tooltip" data-placement="top"><i class="icon icon-weibo"></i></a></li><li><a href="https://twitter.com/Ctzzhang" target="_blank" title="Twitter" data-toggle="tooltip" data-placement="top"><i class="icon icon-twitter"></i></a></li><li><a href="https://www.behance.net/Ctzzhang" target="_blank" title="Behance" data-toggle="tooltip" data-placement="top"><i class="icon icon-behance"></i></a></li><li><a href="/atom.xml" target="_blank" title="Rss" data-toggle="tooltip" data-placement="top"><i class="icon icon-rss"></i></a></li></ul><div class="copyright"><div class="publishby">Theme by <a href="https://github.com/cofess" target="_blank">cofess </a><a href="https://github.com/cofess/hexo-theme-pure" target="_blank"></a></div></div><div class="beian-info"><a href="http://www.miitbeian.gov.cn/">粤ICP备18145042号-1</a></div></footer><script src="//cdn.jsdelivr.net/npm/jquery@1.12.4/dist/jquery.min.js"></script><script>window.jQuery||document.write('<script src="js/jquery.min.js"><\/script>')</script><script src="/js/plugin.min.js"></script><script src="/js/application.js"></script><script>!function(T){var N={TRANSLATION:{POSTS:"文章",PAGES:"页面",CATEGORIES:"分类",TAGS:"标签",UNTITLED:"(未命名)"},ROOT_URL:"/",CONTENT_URL:"/content.json"};T.INSIGHT_CONFIG=N}(window)</script><script src="/js/insight.js"></script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="//cdn.jsdelivr.net/npm/valine"></script><script type="text/javascript">var GUEST=["nick","mail","link"],meta="nick,mail,link";meta=meta.split(",").filter(function(e){return GUEST.indexOf(e)>-1}),new Valine({el:"#vcomments",verify:!1,notify:!1,appId:"",appKey:"",placeholder:"Just go go",avatar:"mm",meta:meta,pageSize:"10",visitor:!1})</script></body></html><!-- rebuild by neat -->