{"meta":{"title":"ctzzhang","subtitle":null,"description":null,"author":"Ctzzhang","url":"http://localhost:4000","root":"/"},"pages":[{"title":"关于","date":"2019-06-16T07:30:14.312Z","updated":"2019-06-16T07:30:14.312Z","comments":false,"path":"about/index.html","permalink":"http://localhost:4000/about/index.html","excerpt":"","text":"欢迎访问我的博客，我会保持不定期更新。/** * * ━━━━━━神兽出没━━━━━━┏┓ ┏┓┃ ┃ + +┃ ━ ┃ ++ + + +████━████ ┃ 🚂🚂🚂-&lt;-&lt; 欢迎访问 https://ctzzhang.github.io/┃ ┃ +┃ ┻ ┃ + +┃ ┃┗━┓ ┏━┛Code is far away from bug with the animal protecting┃ ┃ 神兽护体，永无bug┃ ┃ +┃ ┗━━━┓+┃ ┣┓ 📬 联系我：tzzhang021.com(at)163.com┃ ┏┛ + +┗┓┓┏━┳┓┏┛ +┃┫┫ ┃┫┫┗┻┛ ┗┻┛/"},{"title":"书单","date":"2019-06-16T07:30:14.364Z","updated":"2019-06-16T07:30:14.364Z","comments":false,"path":"books/index.html","permalink":"http://localhost:4000/books/index.html","excerpt":"","text":""},{"title":"分类","date":"2019-06-16T07:30:14.382Z","updated":"2019-06-16T07:30:14.382Z","comments":false,"path":"categories/index.html","permalink":"http://localhost:4000/categories/index.html","excerpt":"","text":""},{"title":"友情链接","date":"2019-06-16T07:30:14.380Z","updated":"2019-06-16T07:30:14.380Z","comments":true,"path":"links/index.html","permalink":"http://localhost:4000/links/index.html","excerpt":"","text":""},{"title":"Repositories","date":"2019-06-16T07:30:14.625Z","updated":"2019-06-16T07:30:14.625Z","comments":false,"path":"repository/index.html","permalink":"http://localhost:4000/repository/index.html","excerpt":"","text":""},{"title":"标签","date":"2019-06-16T07:30:14.367Z","updated":"2019-06-16T07:30:14.367Z","comments":false,"path":"tags/index.html","permalink":"http://localhost:4000/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"基于Zookeeper的分布式锁实现","slug":"间隙限流算法","date":"2019-06-15T14:24:02.000Z","updated":"2019-06-16T07:30:14.853Z","comments":true,"path":"2019/06/15/间隙限流算法/","link":"","permalink":"http://localhost:4000/2019/06/15/间隙限流算法/","excerpt":"","text":"1.简介","categories":[{"name":"中间件","slug":"中间件","permalink":"http://localhost:4000/categories/中间件/"},{"name":"Zookeeper","slug":"中间件/Zookeeper","permalink":"http://localhost:4000/categories/中间件/Zookeeper/"}],"tags":[{"name":"Zookeeper","slug":"Zookeeper","permalink":"http://localhost:4000/tags/Zookeeper/"},{"name":"中间件","slug":"中间件","permalink":"http://localhost:4000/tags/中间件/"},{"name":"分布式","slug":"分布式","permalink":"http://localhost:4000/tags/分布式/"},{"name":"锁","slug":"锁","permalink":"http://localhost:4000/tags/锁/"}]},{"title":"Java线程池的原理分析","slug":"Java线程池","date":"2019-06-15T14:24:02.000Z","updated":"2019-06-16T07:30:14.678Z","comments":true,"path":"2019/06/15/Java线程池/","link":"","permalink":"http://localhost:4000/2019/06/15/Java线程池/","excerpt":"","text":"Java线程池的原理分析1.简介随着并发的不断增加，单个线程的创建和销毁会带来大量的资源开销。通过线程池 我们可以方便的复用线程，避免了频繁创建和销毁线程所带来的开销。在应用上，线程池可应用在后端相关服务中。比如 Web 服务器，数据库服务器等。以 Web 服务器为例，假如 Web 服务器会收到大量短时的 HTTP 请求，如果此时我们简单的为每个 HTTP 请求创建一个处理线程，那么服务器的资源将会很快被耗尽。当然我们也可以自己去管理并复用已创建的线程，以限制资源的消耗量，但这样会使用程序的逻辑变复杂。好在，幸运的是，我们不必那样做。在 JDK 1.5 中，官方已经提供了强大的线程池工具类。通过使用这些工具类，我们可以用低廉的代价使用多线程技术。在Java用有一个Executors工具类，可以为我们创建一个线程池，其本质就是new了一个ThreadPoolExecutor对象。 觉得很有必要去学习一下线程池的相关原理。毕竟线程池除了要管理线程，还要管理任务，同时还要具备统计功能。所以多了解一点，还是可以扩充眼界的，同时也可以更为熟悉线程池技术。2.Executor继承关系线程池所采用的接口和类的结构如下图如上图，最顶层的接口 Executor 仅声明了一个方法execute。ExecutorService 接口在其父类接口基础上，声明了包含但不限于shutdown、submit、invokeAll、invokeAny 等方法。至于 ScheduledExecutorService 接口，则是声明了一些和定时任务相关的方法，比如 schedule和scheduleAtFixedRate。线程池的核心实现是在 ThreadPoolExecutor 类中，我们使用 Executors 调用newFixedThreadPool、newSingleThreadExecutor和newCachedThreadPool等方法创建线程池均是 ThreadPoolExecutor 类型。以上是对线程池继承体系的简单介绍，这里先让大家对线程池大致轮廓有一定的了解。接下来我会介绍一下线程池的实现原理，继续往下看吧。3.原理分析3.1核心关系分析3.1.1核心参数简介如上节所说，线程池的核心实现即 ThreadPoolExecutor 类。该类包含了几个核心属性，这些属性在可在构造方法进行初始化。在介绍核心属性前，我们先来看看 ThreadPoolExecutor 的构造方法，如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748/** * Creates a new &#123;@code ThreadPoolExecutor&#125; with the given initial * parameters. * * @param corePoolSize the number of threads to keep in the pool, even * if they are idle, unless &#123;@code allowCoreThreadTimeOut&#125; is set * @param maximumPoolSize the maximum number of threads to allow in the * pool * @param keepAliveTime when the number of threads is greater than * the core, this is the maximum time that excess idle threads * will wait for new tasks before terminating. * @param unit the time unit for the &#123;@code keepAliveTime&#125; argument * @param workQueue the queue to use for holding tasks before they are * executed. This queue will hold only the &#123;@code Runnable&#125; * tasks submitted by the &#123;@code execute&#125; method. * @param threadFactory the factory to use when the executor * creates a new thread * @param handler the handler to use when execution is blocked * because the thread bounds and queue capacities are reached * @throws IllegalArgumentException if one of the following holds:&lt;br&gt; * &#123;@code corePoolSize &lt; 0&#125;&lt;br&gt; * &#123;@code keepAliveTime &lt; 0&#125;&lt;br&gt; * &#123;@code maximumPoolSize &lt;= 0&#125;&lt;br&gt; * &#123;@code maximumPoolSize &lt; corePoolSize&#125; * @throws NullPointerException if &#123;@code workQueue&#125; * or &#123;@code threadFactory&#125; or &#123;@code handler&#125; is null */public ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue, ThreadFactory threadFactory, RejectedExecutionHandler handler) &#123; if (corePoolSize &lt; 0 || maximumPoolSize &lt;= 0 || maximumPoolSize &lt; corePoolSize || keepAliveTime &lt; 0) throw new IllegalArgumentException(); if (workQueue == null || threadFactory == null || handler == null) throw new NullPointerException(); this.corePoolSize = corePoolSize; this.maximumPoolSize = maximumPoolSize; this.workQueue = workQueue; this.keepAliveTime = unit.toNanos(keepAliveTime); this.threadFactory = threadFactory; this.handler = handler;&#125;如上所示，构造方法的参数即核心参数，这里我用一个表格来简要说明一下各个参数的意义。如下：参数说明corePoolSize核心线程数。当线程数小于该值时，线程池会优先创建新线程来执行新任务maximumPoolSize线程池所能维护的最大线程数keepAliveTime空闲线程的存活时间workQueue任务队列，用于缓存未执行的任务threadFactory线程工厂。可通过工厂为新建的线程设置更有意义的名字handler拒绝策略。当线程池和任务队列均处于饱和状态时，使用拒绝策略处理新任务。默认是 AbortPolicy，即直接抛出异常以上是各个参数的简介，下面我将会针对部分参数进行详细说明，继续往下看。3.1.2线程创建规则在 Java 线程池实现中，线程池所能创建的线程数量受限于 corePoolSize 和 maximumPoolSize 两个参数值。线程的创建时机则和 corePoolSize 以及 workQueue 两个参数有关。下面列举一下线程创建的4个规则（线程池中无空闲线程），如下：线程数量小于corePoolSize ，直接新创建线程处理任务线程数量大于等于corePoolSize ，workQueue 未满时，缓存新任务线程数量大于等于corePoolSize ，小于maximumPoolSize，且 workQueue 已满，则创建新线程处理新任务线程数量大于等于 maximumPoolSize，且 workQueue 已满，则使用拒绝策略处理新任务规则如下序号规则动作1线程数 &lt; corePoolSize创建新线程2线程数 &gt;= corePoolSize ，且 workQueue 未满缓存新任务3corePoolSize ≤ 线程数 ＜ maximumPoolSize，且 workQueue 已满创建新线程4线程数 ≥ maximumPoolSize，且 workQueue 已满使用拒绝策略处理3.1.3资源回收考虑到系统资源是有限的，对于线程池超出 corePoolSize 数量的空闲线程应进行回收操作。进行此操作存在一个问题，即回收时机。目前的实现方式是当线程空闲时间超过 keepAliveTime 后，进行回收。除了核心线程数之外的线程可以进行回收，核心线程内的空闲线程也可以进行回收。回收的前提是allowCoreThreadTimeOut属性被设置为 true，通过public void allowCoreThreadTimeOut(boolean) 方法可以设置属性值。3.1.4排队策略如3.1.2 线程创建规则一节中规则2所说，当线程数量大于等于 corePoolSize，workQueue 未满时，则缓存新任务。这里要考虑使用什么类型的容器缓存新任务，通过 JDK 文档介绍，我们可知道有3中类型的容器可供使用，分别是同步队列，有界队列和无界队列。对于有优先级的任务，这里还可以增加优先级队列。以上所介绍的4中类型的队列，对应的实现类如下：实现类类型说明SynchronousQueue同步队列该队列不存储元素，每个插入操作必须等待另一个线程调用移除操作，否则插入操作会一直阻塞ArrayBlockingQueue有界队列基于数组的阻塞队列，按照 FIFO 原则对元素进行排序LinkedBlockingQueue无界队列基于链表的阻塞队列，按照 FIFO 原则对元素进行排序PriorityBlockingQueue优先级队列具有优先级的阻塞队列3.1.5拒绝策略如3.1.2 线程创建规则一节中规则4所说，线程数量大于等于 maximumPoolSize，且 workQueue 已满，则使用拒绝策略处理新任务。Java 线程池提供了4中拒绝策略实现类，如下：实现类说明AbortPolicy （默认）丢弃新任务，并抛出 RejectedExecutionExceptionDiscardPolicy不做任何操作，直接丢弃新任务DiscardOldestPolicy丢弃队列队首的元素，并执行新任务CallerRunsPolicy由调用线程执行新任务以上4个拒绝策略中，AbortPolicy 是线程池实现类所使用的策略。我们也可以通过方法public void setRejectedExecutionHandler(RejectedExecutionHandler)修改线程池决绝策略。3.2 重要操作3.2.1线程的创建与复用在线程池的实现上，线程的创建是通过线程工厂接口ThreadFactory的实现类来完成的。默认情况下，线程池使用Executors.defaultThreadFactory()方法返回的线程工厂实现类。当然，我们也可以通过public void setThreadFactory(ThreadFactory)方法进行动态修改。具体细节这里就不多说了，并不复杂，大家可以自己去看下源码。在线程池中，线程的复用是线程池的关键所在。这就要求线程在执行完一个任务后，不能立即退出。对应到具体实现上，工作线程在执行完一个任务后，会再次到任务队列获取新的任务。如果任务队列中没有任务，且 keepAliveTime 也未被设置，工作线程则会被一致阻塞下去。通过这种方式即可实现线程复用。说完原理，再来看看线程的创建和复用的相关代码（基于 JDK 1.8），如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120private final class Worker extends AbstractQueuedSynchronizer implements Runnable &#123; /** * This class will never be serialized, but we provide a * serialVersionUID to suppress a javac warning. */ private static final long serialVersionUID = 6138294804551838833L; /** Thread this worker is running in. Null if factory fails. */ final Thread thread; /** Initial task to run. Possibly null. */ Runnable firstTask; /** Per-thread task counter */ volatile long completedTasks; /** * Creates with given first task and thread from ThreadFactory. * @param firstTask the first task (null if none) */ Worker(Runnable firstTask) &#123; setState(-1); // inhibit interrupts until runWorker this.firstTask = firstTask; // 调用线程工厂创建线程 this.thread = getThreadFactory().newThread(this); &#125; /** Delegates main run loop to outer runWorker */ public void run() &#123; //具体的执行 runWorker(this); &#125; // Lock methods // // The value 0 represents the unlocked state. // The value 1 represents the locked state. protected boolean isHeldExclusively() &#123; return getState() != 0; &#125; protected boolean tryAcquire(int unused) &#123; if (compareAndSetState(0, 1)) &#123; setExclusiveOwnerThread(Thread.currentThread()); return true; &#125; return false; &#125; protected boolean tryRelease(int unused) &#123; setExclusiveOwnerThread(null); setState(0); return true; &#125; public void lock() &#123; acquire(1); &#125; public boolean tryLock() &#123; return tryAcquire(1); &#125; public void unlock() &#123; release(1); &#125; public boolean isLocked() &#123; return isHeldExclusively(); &#125; void interruptIfStarted() &#123; Thread t; if (getState() &gt;= 0 &amp;&amp; (t = thread) != null &amp;&amp; !t.isInterrupted()) &#123; try &#123; t.interrupt(); &#125; catch (SecurityException ignore) &#123; &#125; &#125; &#125; &#125;//具体的执行final void runWorker(Worker w) &#123; Thread wt = Thread.currentThread(); Runnable task = w.firstTask; w.firstTask = null; w.unlock(); // allow interrupts boolean completedAbruptly = true; try &#123; // 循环从任务队列中获取新任务 while (task != null || (task = getTask()) != null) &#123; w.lock(); // If pool is stopping, ensure thread is interrupted; // if not, ensure thread is not interrupted. This // requires a recheck in second case to deal with // shutdownNow race while clearing interrupt if ((runStateAtLeast(ctl.get(), STOP) || (Thread.interrupted() &amp;&amp; runStateAtLeast(ctl.get(), STOP))) &amp;&amp; !wt.isInterrupted()) wt.interrupt(); try &#123; beforeExecute(wt, task); Throwable thrown = null; try &#123; // 执行新任务 task.run(); &#125; catch (RuntimeException x) &#123; thrown = x; throw x; &#125; catch (Error x) &#123; thrown = x; throw x; &#125; catch (Throwable x) &#123; thrown = x; throw new Error(x); &#125; finally &#123; afterExecute(task, thrown); &#125; &#125; finally &#123; task = null; w.completedTasks++; w.unlock(); &#125; &#125; completedAbruptly = false; &#125; finally &#123; // 线程退出后，进行后续处理 processWorkerExit(w, completedAbruptly); &#125; &#125;3.2.2 提交任务通常情况下，我们可以通过线程池的submit方法提交任务。被提交的任务可能会立即执行，也可能会被缓存或者被拒绝。任务的处理流程如下图所示：上面的流程图不是很复杂，下面再来看看流程图对应的代码，如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106+---- AbstractExecutorService.javapublic Future&lt;?&gt; submit(Runnable task) &#123; if (task == null) throw new NullPointerException(); // 创建任务 RunnableFuture&lt;Void&gt; ftask = newTaskFor(task, null); // 提交任务 execute(ftask); return ftask;&#125;+---- ThreadPoolExecutor.javapublic void execute(Runnable command) &#123; if (command == null) throw new NullPointerException(); int c = ctl.get(); // 如果工作线程数量 &lt; 核心线程数，则创建新线程 if (workerCountOf(c) &lt; corePoolSize) &#123; // 添加工作者对象 if (addWorker(command, true)) return; c = ctl.get(); &#125; // 缓存任务，如果队列已满，则 offer 方法返回 false。否则，offer 返回 true if (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123; int recheck = ctl.get(); if (! isRunning(recheck) &amp;&amp; remove(command)) reject(command); else if (workerCountOf(recheck) == 0) addWorker(null, false); &#125; // 添加工作者对象，并在 addWorker 方法中检测线程数是否小于最大线程数 else if (!addWorker(command, false)) // 线程数 &gt;= 最大线程数，使用拒绝策略处理任务 reject(command);&#125;private boolean addWorker(Runnable firstTask, boolean core) &#123; retry: for (;;) &#123; int c = ctl.get(); int rs = runStateOf(c); // Check if queue empty only if necessary. if (rs &gt;= SHUTDOWN &amp;&amp; ! (rs == SHUTDOWN &amp;&amp; firstTask == null &amp;&amp; ! workQueue.isEmpty())) return false; for (;;) &#123; int wc = workerCountOf(c); // 检测工作线程数与核心线程数或最大线程数的关系 if (wc &gt;= CAPACITY || wc &gt;= (core ? corePoolSize : maximumPoolSize)) return false; if (compareAndIncrementWorkerCount(c)) break retry; c = ctl.get(); // Re-read ctl if (runStateOf(c) != rs) continue retry; // else CAS failed due to workerCount change; retry inner loop &#125; &#125; boolean workerStarted = false; boolean workerAdded = false; Worker w = null; try &#123; // 创建工作者对象，细节参考上一节所贴代码 w = new Worker(firstTask); final Thread t = w.thread; if (t != null) &#123; final ReentrantLock mainLock = this.mainLock; mainLock.lock(); try &#123; int rs = runStateOf(ctl.get()); if (rs &lt; SHUTDOWN || (rs == SHUTDOWN &amp;&amp; firstTask == null)) &#123; if (t.isAlive()) // precheck that t is startable throw new IllegalThreadStateException(); // 将 worker 对象添加到 workers 集合中 workers.add(w); int s = workers.size(); // 更新 largestPoolSize 属性 if (s &gt; largestPoolSize) largestPoolSize = s; workerAdded = true; &#125; &#125; finally &#123; mainLock.unlock(); &#125; if (workerAdded) &#123; // 开始执行任务 t.start(); workerStarted = true; &#125; &#125; &#125; finally &#123; if (! workerStarted) addWorkerFailed(w); &#125; return workerStarted;&#125;3.2.3 关闭线程池我们可以通过shutdown和shutdownNow两个方法关闭线程池。两个方法的区别在于，shutdown 会将线程池的状态设置为SHUTDOWN，同时该方法还会中断空闲线程。shutdownNow 则会将线程池状态设置为STOP，并尝试中断所有的线程。中断线程使用的是Thread.interrupt方法，未响应中断方法的任务是无法被中断的。最后，shutdownNow 方法会将未执行的任务全部返回。调用 shutdown 和 shutdownNow 方法关闭线程池后，就不能再向线程池提交新任务了。对于处于关闭状态的线程池，会使用拒绝策略处理新提交的任务。4.几种线程池一般情况下，我们并不直接使用 ThreadPoolExecutor 类创建线程池，而是通过 Executors 工具类去构建线程池。通过 Executors 工具类，我们可以构造5中不同的线程池。下面通过一个表格简单介绍一下几种线程池，如下：构造方法说明newFixedThreadPool(int nThreads)构建包含固定线程数的线程池，默认情况下，空闲线程不会被回收newCachedThreadPool()构建线程数不定的线程池，线程数量随任务量变动，空闲线程存活时间超过60秒后会被回收newSingleThreadExecutor()构建线程数为1的线程池，等价于 newFixedThreadPool(1) 所构造出的线程池newScheduledThreadPool(int corePoolSize)构建核心线程数为 corePoolSize，可执行定时任务的线程池newSingleThreadScheduledExecutor()等价于 newScheduledThreadPool(1)5.总结一般需要根据任务的类型来配置线程池大小：如果是CPU密集型任务，就需要尽量压榨CPU，参考值可以设为 NCPU+1如果是IO密集型任务，参考值可以设置为2*NCPU当然，这只是一个参考值，具体的设置还需要根据实际情况进行调整，比如可以先将线程池大小设置为参考值，再观察任务运行情况和系统负载、资源利用率来进行适当调整。参考http://blog.163.com/among_1985/blog/static/275005232012618849266/http://developer.51cto.com/art/201203/321885.htmhttp://blog.csdn.net/cutesource/article/details/6061229http://blog.csdn.net/xieyuooo/article/details/8718741","categories":[{"name":"Java基础","slug":"Java基础","permalink":"http://localhost:4000/categories/Java基础/"},{"name":"并发","slug":"Java基础/并发","permalink":"http://localhost:4000/categories/Java基础/并发/"}],"tags":[{"name":"锁","slug":"锁","permalink":"http://localhost:4000/tags/锁/"},{"name":"Java基础","slug":"Java基础","permalink":"http://localhost:4000/tags/Java基础/"},{"name":"开发","slug":"开发","permalink":"http://localhost:4000/tags/开发/"},{"name":"线程池","slug":"线程池","permalink":"http://localhost:4000/tags/线程池/"}]},{"title":"Hello World","slug":"hello-world","date":"2019-06-14T13:48:34.388Z","updated":"2019-06-16T07:30:14.246Z","comments":true,"path":"2019/06/14/hello-world/","link":"","permalink":"http://localhost:4000/2019/06/14/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.Quick StartCreate a new post1$ hexo new \"My New Post\"More info: WritingRun server1$ hexo serverMore info: ServerGenerate static files1$ hexo generateMore info: GeneratingDeploy to remote sites1$ hexo deployMore info: Deployment","categories":[],"tags":[]}]}